from Crypto.Util import number as n
from functools import reduce
import operator

p=16158504202402426253991131950366800551482053399193655122805051657629706040252641329369229425927219006956473742476903978788728372679662561267749592756478584653187379668070077471640233053267867940899762269855538496229272646267260199331950754561826958115323964167572312112683234368745583189888499363692808195228055638616335542328241242316003188491076953028978519064222347878724668323621195651283341378845128401263313070932229612943555693076384094095923209888318983438374236756194589851339672873194326246553955090805398391550192769994438594243178242766618883803256121122147083299821412091095166213991439958926015606973543
q=13479974306915323548855049186344013292925286365246579443817723220231
g=9891663101749060596110525648800442312262047621700008710332290803354419734415239400374092972505760368555033978883727090878798786527869106102125568674515087767296064898813563305491697474743999164538645162593480340614583420272697669459439956057957775664653137969485217890077966731174553543597150973233536157598924038645446910353512441488171918287556367865699357854285249284142568915079933750257270947667792192723621634761458070065748588907955333315440434095504696037685941392628366404344728480845324408489345349308782555446303365930909965625721154544418491662738796491732039598162639642305389549083822675597763407558360

sk1=10046861250588975243499176841186459239945252023965781404474235095048
sk2=11322232591408348876653279113214212884960271456737992898057963082182
sk3=5530230574242822098028164317251993858819889375005228545746444961699

print(f"n.size(p)    : {n.size(p)} bits.")
print(f"n.isPrime(p) : {n.isPrime(p)}")
print(f"n.size(q)    : {n.size(q)} bits.")
print(f"(p-1) % q    : {(p-1) % q}")
print(f"n.isPrime(q) : {n.isPrime(q)}")
print(f"pow(g, q, p) : {pow(g, q, p)}")


def factorise(num, prime_factors, next_factor):
    if n.isPrime(num):
        prime_factors.append(num)
        return prime_factors

    if next_factor != 1:
        prime_factors.append(next_factor)
        return factorise(num // next_factor, prime_factors, 1)
    
    # order of magnitude of square root
    approx_sqrt_num = pow(2, n.size(num) // 2)
    # run 3 iterations of Newtons method for approximation square root
    for i in range(3):
        approx_sqrt_num = (approx_sqrt_num**2 + num) // 2*approx_sqrt_num

    # find next factor
    for i in range(2, approx_sqrt_num + 1):
        if num % i == 0:
            return factorise(num, prime_factors, i)
    
    # error : num is not prime but has no factor
    return [-1]

def check_factorization(factors, product):
    for f in factors:
        if not n.isPrime(f):
            print(f"factor {f} is not prime")
            return False
    
    return reduce(operator.mul, factors, 1) == product

fact_pminus1 = factorise(p-1, [], q)
print(f"correct factorization : {check_factorization(fact_pminus1, p-1)}")
print(f"factorisation of p-1 : \n {fact_pminus1}")